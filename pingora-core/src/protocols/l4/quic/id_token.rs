// Copyright (C) 2020, Cloudflare, Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

use log::trace;
use quiche::{ConnectionId, Header};
use ring::hmac::Key;
use ring::rand::{SecureRandom, SystemRandom};
use std::net;

/// Generate a stateless retry token.
///
/// The token includes the static string `"quiche"` followed by the IP address
/// of the client and by the original destination connection ID generated by the
/// client.
///
/// Note that this function is only an example and doesn't do any cryptographic
/// authenticate of the token. *It should not be used in production system*.
pub(crate) fn mint_token(hdr: &quiche::Header, src: &net::SocketAddr) -> Vec<u8> {
    // TODO: implement token generation/validation using crypto
    let mut token = Vec::new();

    token.extend_from_slice(b"quiche");

    let addr = match src.ip() {
        net::IpAddr::V4(a) => a.octets().to_vec(),
        net::IpAddr::V6(a) => a.octets().to_vec(),
    };

    token.extend_from_slice(&addr);
    token.extend_from_slice(&hdr.dcid);

    token
}

/// Validates a stateless retry token.
///
/// This checks that the ticket includes the `"quiche"` static string, and that
/// the client IP address matches the address stored in the ticket.
///
/// Note that this function is only an example and doesn't do any cryptographic
/// authenticate of the token. *It should not be used in production system*.
pub(crate) fn validate_token<'a>(
    src: &net::SocketAddr,
    token: &'a [u8],
) -> Option<quiche::ConnectionId<'a>> {
    // TODO: implement token generation/validation using crypto
    if token.len() < 6 {
        return None;
    }

    if &token[..6] != b"quiche" {
        return None;
    }

    let token = &token[6..];

    let addr = match src.ip() {
        net::IpAddr::V4(a) => a.octets().to_vec(),
        net::IpAddr::V6(a) => a.octets().to_vec(),
    };

    if token.len() < addr.len() || &token[..addr.len()] != addr.as_slice() {
        return None;
    }

    Some(quiche::ConnectionId::from_ref(&token[addr.len()..]))
}

pub(crate) fn generate_incoming_cid(key: &Key, hdr: &Header) -> ConnectionId<'static> {
    let conn_id = ring::hmac::sign(key, &hdr.dcid);
    let conn_id = conn_id.as_ref()[..quiche::MAX_CONN_ID_LEN].to_vec();
    // dcid
    let conn_id = ConnectionId::from(conn_id);
    trace!("generated incoming connection id {:?}", conn_id);
    conn_id
}

pub(crate) fn generate_outgoing_cid(rng: &SystemRandom) -> ConnectionId<'static> {
    let mut conn_id = [0; quiche::MAX_CONN_ID_LEN];
    rng.fill(&mut conn_id[..]).unwrap();
    // scid
    let conn_id = ConnectionId::from(conn_id.to_vec());
    trace!("generated outgoing connection id {:?}", conn_id);
    conn_id
}
